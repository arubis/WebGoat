package org.owasp.webgoat.lessons.missingac;

import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.owasp.webgoat.container.LessonDataSource;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

public class MissingAccessControlUserRepositorySQLInjectionTest {

  private NamedParameterJdbcTemplate mockJdbcTemplate;
  private MissingAccessControlUserRepository repository;
  private ArgumentCaptor<String> queryCaptor;

  @BeforeEach
  public void setUp() {
    LessonDataSource mockDataSource = mock(LessonDataSource.class);
    mockJdbcTemplate = mock(NamedParameterJdbcTemplate.class);
    queryCaptor = ArgumentCaptor.forClass(String.class);
    
    when(mockJdbcTemplate.query(anyString(), any(RowMapper.class)))
        .thenReturn(new ArrayList<>());
    when(mockJdbcTemplate.query(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
        .thenReturn(new ArrayList<>());
    
    repository = new MissingAccessControlUserRepository(mockDataSource) {
      @Override
      public List<User> findAllUsers() {
        return mockJdbcTemplate.query(
            "select username, password, admin from access_control_users", 
            (rs, rowNum) -> new User(rs.getString("username"), rs.getString("password"), rs.getBoolean("admin")));
      }
      
      @Override
      public User findByUsername(String username) {
        String query = "select username, password, admin from access_control_users where username='" + username + "'";
        return mockJdbcTemplate.query(
            query,
            (rs, rowNum) -> new User(rs.getString("username"), rs.getString("password"), rs.getBoolean("admin")))
            .stream().findFirst().orElse(null);
      }
    };
  }

  @Test
  public void testSQLInjectionInFindByUsername() {
    String sqlInjectionPayload = "admin' OR '1'='1";
    
    repository.findByUsername(sqlInjectionPayload);
    
    verify(mockJdbcTemplate).query(queryCaptor.capture(), any(RowMapper.class));
    String capturedQuery = queryCaptor.getValue();
    
    boolean containsUnsanitizedInput = capturedQuery.contains("' OR '1'='1");
    assertTrue(containsUnsanitizedInput, 
        "SQL Injection vulnerability: User input appears unescaped in query. Query was: " + capturedQuery);
  }

  @Test
  public void testSQLInjectionPayloadNotParameterized() {
    String maliciousUsername = "' OR admin = 't' --";
    
    repository.findByUsername(maliciousUsername);
    
    verify(mockJdbcTemplate).query(queryCaptor.capture(), any(RowMapper.class));
    String executedQuery = queryCaptor.getValue();
    
    if (!executedQuery.contains("' OR admin =")) {
      fail("Expected SQL injection payload to appear unescaped in query, but query was properly parameterized: " + executedQuery);
    }
  }
}