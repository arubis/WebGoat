package org.owasp.webgoat.lessons.missingac;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.util.Collections;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.owasp.webgoat.container.LessonDataSource;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;

public class MissingAccessControlUserRepositorySQLInjectionTest {

  private NamedParameterJdbcTemplate mockJdbcTemplate;
  private MissingAccessControlUserRepository repository;
  private LessonDataSource mockDataSource;

  @BeforeEach
  public void setup() {
    mockDataSource = mock(LessonDataSource.class);
    mockJdbcTemplate = mock(NamedParameterJdbcTemplate.class);
    repository = new MissingAccessControlUserRepository(mockDataSource);
    
    try {
      java.lang.reflect.Field field = repository.getClass().getDeclaredField("jdbcTemplate");
      field.setAccessible(true);
      field.set(repository, mockJdbcTemplate);
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  @Test
  public void testSQLInjectionPrevention() {
    String sqlInjectionPayload = "admin' OR '1'='1";
    
    when(mockJdbcTemplate.query(anyString(), any(SqlParameterSource.class), any(RowMapper.class)))
        .thenReturn(Collections.emptyList());
    
    repository.findByUsername(sqlInjectionPayload);
    
    ArgumentCaptor<String> sqlCaptor = ArgumentCaptor.forClass(String.class);
    ArgumentCaptor<SqlParameterSource> paramsCaptor = ArgumentCaptor.forClass(SqlParameterSource.class);
    
    verify(mockJdbcTemplate).query(sqlCaptor.capture(), paramsCaptor.capture(), any(RowMapper.class));
    
    String executedSQL = sqlCaptor.getValue();
    
    assertFalse(
        executedSQL.contains("' OR '1'='1"),
        "SQL Injection vulnerability: Payload appears unescaped in query. Query was: " + executedSQL
    );
    
    assertFalse(
        executedSQL.contains(sqlInjectionPayload),
        "SQL Injection vulnerability: User input concatenated directly into SQL query"
    );
  }
}