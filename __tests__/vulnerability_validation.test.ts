

import { describe, it, expect, beforeEach, vi } from 'vitest';
import path from 'path';
import fs from 'fs';

describe('SQL Injection Prevention - CustomGoat.js', () => {
  let customGoatModule;

  beforeEach(() => {
    // Mock AMD define function to capture the module
    global.define = vi.fn((deps, factory) => {
      // Mock jQuery
      const mockJQuery = vi.fn((selector) => {
        const mockElement = {
          value: vi.fn(() => {
            if (selector === '#travelFrom') {
              return "' OR '1'='1";
            }
            return 'SomeDestination';
          })
        };
        return mockElement;
      });

      // Call factory with mocked dependencies
      customGoatModule = factory(mockJQuery, {}, {}, {});
    });

    // Load the vulnerable source file
    const sourcePath = path.join(process.cwd(), 'src/main/resources/webgoat/static/js/goatApp/support/CustomGoat.js');
    const sourceCode = fs.readFileSync(sourcePath, 'utf8');
    
    // Execute the module code to trigger define()
    eval(sourceCode);
  });

  it('should not include unescaped SQL injection payload in XML output', () => {
    const result = customGoatModule.getFlights();
    
    // RED TEST: Assert that secure code would NOT contain the literal injection payload
    // This FAILS on vulnerable code because the payload appears unescaped
    // This PASSES on fixed code because the payload would be escaped/sanitized
    expect(result).not.toMatch(/'\s*OR\s*'1'\s*=\s*'1/);
  });
});